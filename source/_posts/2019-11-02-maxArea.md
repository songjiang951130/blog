---
title: leetcode 最大盛水量
categories:
  - 算法
tags:
  - leetcode 11
  - 双指针
  - 动态规划
---

# [原题链接](https://leetcode-cn.com/problems/container-with-most-water/)
## 题目描述
给定 n 个非负整数 a1，a2，...，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。

说明：你不能倾斜容器，且 n 的值至少为 2。

# 解法
## 暴力
首先面积计算公式 (j-i)*min(height[i],height[j]),高度由两个height[下标]的较小值决定，跟木桶里的最大成水量由最小一块决定的短板效应一样。

```java
    public int maxArea(int[] height) {
        int max = 0;
        for (int i = 0; i < height.length - 1; i++) {
            for (int j = i + 1; j < height.length; j++) {
                max = Math.max(max, (j - i) * Math.min(height[i], height[j]));
            }
        }
        return max;
    }
```

### 执行结果
执行用时 :269 ms, 在所有 java 提交中击败了30.82% 的用户  
内存消耗 :38.9 MB, 在所有 java 提交中击败了94.20%的用户

很明显还有更好的办法，我们可以从两边向内进行思考，而不是进行两次循环导致O(n^2)的复杂度

## 双指针动态规划
### 思路
从两边向内进行判断,最大盛水量的高度由两边高度的较小（最小）高度决定，小的一边需要往内移动，找更大的边和当前的宽度进行计算面积

```java
    public int maxArea(int[] height) {
        int max = 0;
        int i = 0, j = height.length - 1;
        while (i < j) {
            /**
             * 从两边向内进行判断,最大盛水量的高度由两边高度的较小（最小）高度决定，小的一边需要往内移动，找更大的边和当前的宽度进行计算面积
             */
            int h = height[i] < height[j] ? height[i++] : height[j--];
            //此处已经往内移动了一位，所以要加1补一个宽度
            max = Math.max(max, h * (j - i + 1));
        }
        return max;
    }
```

### 执行结果
执行用时 :3 ms, 在所有 java 提交中击败了96.28%的用户
内存消耗 :39.3 MB, 在所有 java 提交中击败了93.75%的用户

现在已经击败了绝大部分用户了，如果有百分99击败的欢迎留言，相互交流学习
